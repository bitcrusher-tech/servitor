name: Deep Recon Pipeline

on:
  workflow_dispatch:
    inputs:
      target:
        description: "Path to domains list (one per line)"
        required: false
        default: "domains.txt"
      chain:
        description: "After recon, trigger Scan and Report?"
        required: false
        default: "no"
        type: choice
        options:
          - no
          - yes

# Needed so this workflow can dispatch the Scan workflow when chain == 'yes'
permissions:
  contents: read
  actions: write

jobs:
  deep-recon:
    runs-on: ubuntu-latest
    timeout-minutes: 90

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22.x'
          cache: true

      - name: Install OS dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libpcap-dev build-essential pkg-config

      - name: Show inputs + validate target file
        run: |
          echo "Target file: ${{ github.event.inputs.target }}"
          echo "Chain after recon: ${{ github.event.inputs.chain || 'no' }}"
          echo "Repository layout:"
          ls -la
          
          if [ ! -f "${{ github.event.inputs.target }}" ]; then
            echo "ERROR: Target file not found: ${{ github.event.inputs.target }}"
            exit 1
          fi
          
          echo "---- Target domains (first 20) ----"
          head -20 "${{ github.event.inputs.target }}"
          echo "Total domains: $(wc -l < ${{ github.event.inputs.target }})"

      - name: Install Recon Tools
        run: |
          set -x
          go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
          go install -v github.com/projectdiscovery/dnsx/cmd/dnsx@latest
          go install -v github.com/projectdiscovery/naabu/v2/cmd/naabu@latest
          go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest
          go install -v github.com/projectdiscovery/katana/cmd/katana@latest
          go install -v github.com/tomnomnom/waybackurls@latest
          go install -v github.com/projectdiscovery/notify/cmd/notify@latest
          echo "${HOME}/go/bin" >> "$GITHUB_PATH"

      - name: Subdomain Enumeration
        run: |
          set -x
          echo "Starting subdomain enumeration..."
          
          # Single default tier: just run
          subfinder -dL "${{ github.event.inputs.target }}" -all -o subdomains_raw.txt -v
          
          # Remove duplicates and clean up
          sort -u subdomains_raw.txt > subdomains_clean.txt
          mv subdomains_clean.txt subdomains_raw.txt
          
          echo "Raw subdomains found: $(wc -l < subdomains_raw.txt)"

      - name: DNS Resolution & Validation
        run: |
          set -x
          echo "Validating DNS resolution..."
          
          # Resolve subdomains and get IPs/records
          dnsx -l subdomains_raw.txt -resp-only -o subdomains_resolved.txt -v
          dnsx -l subdomains_raw.txt -a -aaaa -cname -resp -o dns_records.txt -v
          
          echo "Resolved subdomains: $(wc -l < subdomains_resolved.txt)"

      - name: Build Scanning Targets
        run: |
          set -x
          if [ -s subdomains_resolved.txt ]; then
            cp subdomains_resolved.txt targets.txt
            echo "Using $(wc -l < targets.txt) resolved subdomains for scanning"
          else
            cp "${{ github.event.inputs.target }}" targets.txt
            echo "No subdomains resolved, using original $(wc -l < targets.txt) domains"
          fi
          
          # Normalize targets - remove protocols and paths
          awk '{
            gsub(/^https?:\/\//,"")
            split($0,a,"/")
            print a[1]
          }' targets.txt | sed '/^$/d' | sort -u > targets_normalized.txt
          mv targets_normalized.txt targets.txt
          
          echo "Final target count: $(wc -l < targets.txt)"
          echo "Sample targets:"
          head -10 targets.txt

      - name: Port Scanning
        run: |
          set -x
          echo "Starting port scan..."
          
          # Single default: previously "medium"
          PORTS="-top-ports 1000"
          naabu -list targets.txt $PORTS -rate 10000 -o open_ports.txt -v
          
          echo "Open ports found: $(wc -l < open_ports.txt)"
          echo "Sample open ports:"
          head -20 open_ports.txt || true

      - name: HTTP Service Discovery
        run: |
          set -x
          echo "Probing HTTP services..."
          
          # Probe both targets and open ports
          httpx -l targets.txt -status-code -title -ip -tech-detect -follow-redirects -o live_hosts_from_domains.txt -v
          
          # If we have open ports, probe those too
          if [ -s open_ports.txt ]; then
            httpx -l open_ports.txt -status-code -title -ip -tech-detect -follow-redirects -o live_hosts_from_ports.txt -v
            cat live_hosts_from_domains.txt live_hosts_from_ports.txt | sort -u > live_hosts.txt
          else
            mv live_hosts_from_domains.txt live_hosts.txt
          fi
          
          echo "Live HTTP services: $(wc -l < live_hosts.txt)"
          echo "Sample live hosts:"
          head -10 live_hosts.txt || true

      - name: Endpoint Discovery
        run: |
          set -x
          echo "Crawling endpoints..."
          
          # Use live hosts if available, otherwise targets
          SOURCE_FILE="live_hosts.txt"
          [ -s "$SOURCE_FILE" ] || SOURCE_FILE="targets.txt"
          
          # Single default depth (previously "medium")
          DEPTH=2
          
          echo "Using source: $SOURCE_FILE ($(wc -l < $SOURCE_FILE) entries)"
          
          # Katana crawling
          katana -list "$SOURCE_FILE" -d $DEPTH -jc -kf all -aff -o katana_endpoints.txt -v || true
          
          # Wayback URLs
          cat "$SOURCE_FILE" | waybackurls > wayback_endpoints.txt || true
          
          # Combine and deduplicate
          cat katana_endpoints.txt wayback_endpoints.txt 2>/dev/null | sort -u > all_endpoints.txt
          
          echo "Total endpoints discovered: $(wc -l < all_endpoints.txt)"

      - name: Generate Recon Summary
        run: |
          cat > recon_summary.txt << EOF
# Recon Summary - $(date)
Target File: ${{ github.event.inputs.target }}
Scope: run
Runtime: $(date)

## Statistics
- Original domains: $(wc -l < ${{ github.event.inputs.target }})
- Subdomains found: $(wc -l < subdomains_raw.txt || echo 0)
- DNS resolved: $(wc -l < subdomains_resolved.txt || echo 0)
- Final targets: $(wc -l < targets.txt || echo 0)
- Open ports: $(wc -l < open_ports.txt || echo 0)
- Live HTTP services: $(wc -l < live_hosts.txt || echo 0)
- Endpoints discovered: $(wc -l < all_endpoints.txt || echo 0)

Ready for vulnerability scanning phase.
EOF
          
          echo "=== RECON SUMMARY ==="
          cat recon_summary.txt

      - name: Upload Recon Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: recon-data
          retention-days: 30
          path: |
            targets.txt
            open_ports.txt
            live_hosts.txt
            all_endpoints.txt
            dns_records.txt
            recon_summary.txt

      - name: Kick off Vulnerability Scanning (if requested)
        if: ${{ (github.event.inputs.chain || 'no') == 'yes' }}
        run: |
          echo "Dispatching 'Vulnerability Scanning Pipeline'..."
          curl -sSL -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/scan_pipeline.yaml/dispatches \
            -d '{"ref":"${{ github.ref_name }}"}'
